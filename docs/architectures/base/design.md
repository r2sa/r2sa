# 常用设计手段

## 高可用设计手段
- what
	- 高可用通常是指，通过设计减少系统不能提供服务的时间。
- why
	- 硬件和软件带来的不可用性
- 高可用的衡量标准
	- 可用性
		- 在给定时间段内特定系统或组件的正常运行时间
	- 容灾恢复能力
		- RPO :（Recovery Point Obejective，恢复点目标）是指业务系统所允许的在灾难过程中的最大数据丢失量，用来衡量容灾系统的数据冗余备份能力
		- RTO :（Recovery Time Objective，恢复时间目标）是指信息系统从灾难状态恢复到可运行状态所需的时间，用来衡量容灾系统的业务恢复能力
- 设计手段
	- 服务冗余
	- 无状态化
	- 负载均衡
	- 幂等设计
	- 超时机制
	- 异步化设计
	- 服务限流降级熔断
	- 数据复制、缓存、sharding
	- 架构拆分、服务治理
	- 日志监控
	- 服务分级

### 如何无缝停止线上服务
- 若网关层已具备热切换能力
	- 热开关切换
		- 看server端日志打印情况
		- 按客户端超时时间
- 网关层不具备热切换能力
	- 防火墙限制只出不进
		- IPTABLES

## 高并发设计手段
- 系统性能
	- 吞吐量
	- 响应延时
	- 关系图 ![性能测试指标及其关系](/architectures/img/1.jpeg)
- 优化手段
	- 时间换空间
		- 数据大小是瓶颈
		- eg:gzip压缩
	- 空间换时间
		- 系统时间是瓶颈
		- eg:缓存
	- 找到系统瓶颈
		- 分析系统业务流程，找到关键路径并分解优化
			- 调用了多少个RPC接口
			- 载入了多少数据
			- 使用了什么算法
			- 非核心流程能否异步化
			- 没有数据依赖的逻辑能否并行执行
- 优化层次
	- 架构设计层次
		- 关注系统控制、数据流程
		- 如何拆分系统、如何使各部分系统负责更加均衡，充分发挥硬件设施性能优势，减少系统内部开销等
	- 算法逻辑层次
		- 关注算法选择是否高效，算法逻辑优化，空间时间优化，任务并行处理，使用无锁数据结构等
		- 空间换时间
		- 时间换空间
	- 代码优化层次

### 性能优化
[性能优化](/architectures/base/optimization.md)

### 高并发场景实例
- [电商秒杀](/architectures/base/flash_sale.md)
- [feed系统](/architectures/base/feed.md)

## 服务无状态设计
### 定义
- 冗余部署的多个模块(进程)完全对等
- 请求提交到冗余部署的任一模块，处理结果完全一样
- 模块不存储业务上的上下文关系
- 仅根据每次请求携带数据进行相应的业务逻辑处理

### 场景实例
- [用户Session数据](https://www.jianshu.com/p/c79fac664439)


## 服务负载均衡设计
### 负载均衡系统
- 硬件
	- F5
	- A10
	- Radware
- 软件
	- LVS
		- 4层
	- Nginx
		- 7层
	- HAProxy
		- 4层或7层
- 反向代理 VS 正向代理

### 负载均衡算法
- Dubbo LoadBalance
	- Random
		- 随机、按权重设置随机概率
	- RoundRobin
		- 轮询，按约定后的权重设置轮询比率
	- ConsistentHash
		- 一致性哈希，相同参数的请求总是发到同一提供者

### 广义负载均衡
- 完整的故障处理回复机制
	- 故障自动发现
	- 故障服务自动摘除
		- 服务熔断机制
	- 请求自动重试
	- 服务恢复自动发现


## 服务幂等设计
### 幂等定义
- 请求层面
	- 保证请求重复执行和执行一次结果相同
	- f(f(x)) = f(x)
		- x是参数
		- f是执行函数/方法
- 业务层面
	- 同一用户不重复下单
	- 商品不超卖
	- MQ消费端去重

### 幂等目的
- 请求重试
- 结果灾难性
	- 转账
	- 交易

### 幂等范围
- 请求层面
	- 请求对数据造成改变
		- 写请求
- 架构层层面
	- 哪些层会对数据造成改变
		- 数据访问层
			- Insert操作
				- 自增主键
					- 可通过唯一索引来做幂等
				- 业务主键(幂等)
			- Update操作
				- 相对值
					- 增加where条件
					- 相对修改转换成绝对修改
					- 事务
						- ☆分布式事务
				- 绝对值(幂等)
			- Delete操作
				- 相对值
				- 绝对值(幂等)
- 业务层面幂等
	- 冗余部署多个进程
		- 存在并发消费的可能性
		- 并发转化为串行消费
	- 本质
		- [分布式锁问题]()

## 分布式锁设计
### 分布式锁定义
- 分布式环境下，锁定全局唯一资源
	- 请求处理串行化
	- 实际表现互斥锁

### 分布式锁场景举例
- 交易订单锁定
	- 防止重复下单
	- 解决业务层幂等问题
- MQ消息消费幂等性
	- 发送消息重复
	- 消息消费端去重
	- 比如手机体现

### 基于Redis分布式锁
- 唯一线程串行处理
- 实现方式
	- Redis Setnx(Set if Not eXists) 命令在指定的key不存在时，为key设置指定的值
		- SETNX KEY_NAME VALUE Expire Time
			- 设置成功，返回1；设置失败，返回0
	- 存在问题
		- 锁时间不可控
			- 无法续租期
		- 单点问题
			- 单实例存在进程一旦死掉，会彻底阻塞业务流程
			- 主从方式，主从数据异步，会存在锁失效问题
		- Redis是AP模型，不适合来做分布式锁(CP要求)
	- 官方建议
		- Redis 本身建议使用Redlock算法来保证
			- 需要至少3个Redis主从实例来完成，维护成本相对较高。
			- Redlock等同于自己实现简单的一致性协议，细节繁琐，且容易出错。


### 高可用分布式锁设计
#### 目标
- 强一致性
- 服务高可用、系统稳定
- 锁自动续约及其自动释放
- 代码高度抽象业务接入极简
- 可视化管理后台、监控及管理

#### 存储层产品对比
||Redis|zookeeper|etcd|
|---|---|---|---|
|一致性算法|无|paxos/ZAB|roft|
|CAP|AP|AP|AP/CP|
|高可用|主从|N+1可用|N+1可用|
|接口类型|客户端|客户端|http/grpc|
|实现|setNX|createEphemerd|restful API|
- Redis无法保证数据一致性
- ZooKeeper对锁实现使用创建临时节点和watch机制，执行效率、扩展能力、社区活跃度等方面低于etcd
- 推荐选择基于etcd实现

#### etcd
- 简单kv
- 强一致
- 高可用
	- 无单点
- 数据高可靠
	- 持久化

#### 分布式锁整体方案
- 分布式Client + etcd
	- Client TTL模式
		- ClientA -> etcd -> {"key","ttl","value","uuid"}
		- ClientB -> etcd -> {"key","ttl","value","uuid"}
		- ClientA 拿锁成功，ClientB 拿锁失败
		- ClientA需要对etcd保持后台心跳线程
			- 比如key的租期是10ms，后台心跳线程为3ms，心跳线程负责在拿到key之后每3ms cas唯一凭证uuid

## 分布式事务设计

## 服务降级设计

## 服务限流/熔断设计

## 服务灰度发布设计

## 服务全链路压测设计